const char* BVHKernelSource = 
"/**\n"
" * @file BVHKernels.cl\n"
" * @author  Timur Sizov <timorgizer@gmail.com>\n"
" * @version 0.6\n"
" *\n"
" * @section LICENSE\n"
" *\n"
" * Copyright (c) 2016 Timur Sizov\n"
" *\n"
" * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n"
" * software and associated documentation files (the \"Software\"), to deal in the Software \n"
" * without restriction, including without limitation the rights to use, copy, modify, merge, \n"
" * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons \n"
" * to whom the Software is furnished to do so, subject to the following conditions:\n"
" * The above copyright notice and this permission notice shall be included in all copies or \n"
" * substantial portions of the Software.\n"
" *\n"
" * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, \n"
" * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE \n"
" * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n"
" * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"
" * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
" *\n"
" * @section DESCRIPTION\n"
" *\n"
" * Kernels BVH construction and traversal.\n"
" * This file contains the entry points for kernels, that call actual logic functions contained in the file BVH.h.\n"
" * \n"
" * @implNote \n"
" * The implemented BVH variation is based on radix trees, \n"
" * adopted from this source:  http://devblogs.nvidia.com/parallelforall/wp-content/uploads/2012/11/karras2012hpg_paper.pdf\n"
" * and related blog entry:    https://devblogs.nvidia.com/parallelforall/thinking-parallel-part-iii-tree-construction-gpu/\n"
" * Handling duplicate Morton codes implemented based on this source: https://github.com/Ooken/NekoEngine\n"
" * \n"
" */\n"
"#include \"CLData\\SceneBufferParser.h\"\n"
"#include \"CLData\\Primitives\\AABB.h\"\n"
"#include \"CLData\\AccelerationStructs\\BVH.h\"\n"
"#include \"CLData\\AccelerationStructs\\BVHData.h\"\n"
"\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"\n"
"/***************************************************\n"
"* 1. Calculate Morton code for each primitive\n"
"****************************************************/\n"
"__kernel void calculateMortonCodes(__global struct BVHNode* leavesBuffer,__global uint2* mortonBuffer, __global const char* scene)\n"
"{\n"
"	if(get_global_id(0) < SCENE_HEADER(scene)->totalNumberOfTriangles) \n"
"		calculateMorton(leavesBuffer,mortonBuffer,get_global_id(0),scene);\n"
"}\n"
"\n"
"/***************************************************\n"
"* 2. Builds the actual hierarchy\n"
"****************************************************/\n"
"__kernel void buildRadixTree(__global struct BVHNode* nodeBuffer,__global uint2* mortonBuffer, uint leafCount)\n"
"{\n"
"	uint idx = get_global_id(0);\n"
"	if (idx < leafCount-2)\n"
"		constructNode(nodeBuffer,mortonBuffer,leafCount, get_global_id(0));\n"
"} \n"
"\n"
"/***************************************************************\n"
"* 3. Hierarchy post-processing - Calculation of bounding boxes\n"
"***************************************************************/\n"
"__kernel void computeBoundingBoxes(__global struct BVHNode* nodeBuffer,__global volatile uint* counters, uint leafCount)\n"
"{\n"
"	CL_UINT current = min((uint)get_global_id(0),(uint)(leafCount-1));\n"
"	current = parent(nodeBuffer[current]);\n"
"	while(current != UINT_MAX)\n"
"	{\n"
"		atomic_inc(counters+(current-leafCount));\n"
"		if (*(counters+(current-leafCount)) > 1)\n"
"		{\n"
"			mergeBoundingBox(nodeBuffer,current);\n"
"			current = parent(nodeBuffer[current]);\n"
"		}\n"
"		else break;\n"
"	}\n"
"}\n"
"\n"
"/***************************************************************\n"
"* 4. Generating the contacts for primary rays\n"
"***************************************************************/\n"
"__kernel void generateContacts(__constant struct Camera* camera,\n"
"							      __global struct BVHNode* bvh, \n"
"							      uint rootIdx,\n"
"							      const __global char* scene,\n"
"							      __global struct Contact* output\n"
"								 )\n"
"{\n"
"		if (get_global_id(0) < (camera->resX * camera->resY))\n"
"		{\n"
"			struct Ray r = generateRay(camera,get_global_id(0));\n"
"			struct Contact c = bvh_generate_contact(r,bvh,rootIdx,scene);\n"
"			c.pixelIndex = get_global_id(0);\n"
"			output[c.pixelIndex] = c;\n"
"		}\n"
"}\n"
"\n"
"/***************************************************************\n"
"* 5. Generating the contacts for general rays\n"
"***************************************************************/\n"
"__kernel void generateContacts2(__global struct Ray* rays,\n"
"							   uint rayCount,\n"
"							   __global struct BVHNode* bvh, \n"
"							   uint rootIdx,\n"
"							   const __global char* scene,\n"
"							   __global struct Contact* output)\n"
"{\n"
"		uint idx = get_global_id(0);\n"
"		if (idx < rayCount)\n"
"		{\n"
"			struct Contact c = bvh_generate_contact(rays[idx],bvh,rootIdx,scene);\n"
"			c.pixelIndex = idx;\n"
"			output[c.pixelIndex] = c;\n"
"		}\n"
"}\n"
"\n"
;
