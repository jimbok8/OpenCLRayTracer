const char* TwoLevelGridKernelSource = 
"/**\n"
" * @file TwoLevelGridKernels.cl\n"
" * @author  Timur Sizov <timorgizer@gmail.com>\n"
" * @version 0.6\n"
" *\n"
" * @section LICENSE\n"
" *\n"
" * Copyright (c) 2016 Timur Sizov\n"
" *\n"
" * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n"
" * software and associated documentation files (the \"Software\"), to deal in the Software \n"
" * without restriction, including without limitation the rights to use, copy, modify, merge, \n"
" * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons \n"
" * to whom the Software is furnished to do so, subject to the following conditions:\n"
" * The above copyright notice and this permission notice shall be included in all copies or \n"
" * substantial portions of the Software.\n"
" *\n"
" * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, \n"
" * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE \n"
" * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n"
" * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"
" * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
" *\n"
" * @section DESCRIPTION\n"
" *\n"
" * Kernel functions for Two Level Grid construction and traversal.\n"
" * \n"
" * This file contains entry points for the kernel - Most of the logic functions are contained in\n"
" * file: TwoLevelGrid.h, for CPU portability\n"
" *\n"
" * @implNote The algorithm implemented according to the article: \"Two-Level Grids for Ray Tracing on GPUs\"\n"
" *           by Javor Kalojanov, Markus Billeter and Philipp Slusallek\n"
" *           http://www.intel-vci.uni-saarland.de/fileadmin/grafik_uploads/publications/59.pdf\n"
" */\n"
"\n"
"#include \"CLData\\AccelerationStructs\\TwoLevelGrid.h\"\n"
"#include \"CLData\\AccelerationStructs\\TwoLevelGridData.h\"\n"
"\n"
"\n"
" /*****************************************************\n"
" * 1. Counts top level pairs\n"
" ******************************************************/\n"
"__kernel void prepareDataKernel(CL_GLOBAL char* scene, \n"
"						  CL_CONSTANT struct GridData* grid,\n"
"						  CL_GLOBAL CL_UINT* counters)\n"
"{\n"
"	uint currentIdx = get_global_id(0);\n"
"	uint tris = SCENE_HEADER(scene)->totalNumberOfTriangles-1;\n"
"	if (currentIdx < tris)\n"
"		prepareGridData(scene,currentIdx,grid,counters);\n"
"}\n"
"\n"
"/*****************************************************\n"
" * 2. Generates top level pairs\n"
" ******************************************************/\n"
"__kernel void writePairsKernel(CL_GLOBAL char* scene, \n"
"					     CL_CONSTANT struct GridData* grid,\n"
"					     CL_GLOBAL CL_UINT* prefixSum,\n"
"					     CL_GLOBAL CL_UINT* counters,\n"
"					     CL_GLOBAL CL_UINT2* pairs)\n"
"{\n"
"	uint currentIdx = get_global_id(0);\n"
"	uint tris = SCENE_HEADER(scene)->totalNumberOfTriangles-1;\n"
"	if (currentIdx < tris)\n"
"		writePairs(scene,currentIdx,grid,prefixSum,counters,pairs);\n"
"}\n"
"\n"
"/*****************************************************\n"
" * 3. Extracts ranges in sorted pairs array\n"
" ******************************************************/\n"
"__kernel void extractCellRangesKernel(CL_GLOBAL CL_UINT2* sortedPairs,\n"
"						         CL_UINT sortedPairsCount,\n"
"						         CL_GLOBAL CL_UINT2* cellRanges,\n"
"								 CL_LOCAL CL_UINT2* localBuf,\n"
"						         CL_UINT workingBlock)\n"
"{\n"
"	const uint batchSize = workingBlock;\n"
"	const uint batches = ceil((float)sortedPairsCount / (float)batchSize);\n"
"	\n"
"	uint maxGlobalIdx = sortedPairsCount - 1;\n"
"	uint currentLocalIdx = get_global_id(0);\n"
"	uint nextLocalIdx;\n"
"	long currentGlobalIdx;\n"
"	uint nextGlobalIdx;\n"
"	for(int i = 0; i < batches; i++)\n"
"	{\n"
"		//load pairs to shared memory\n"
"		nextLocalIdx = currentLocalIdx + 1;\n"
"		currentGlobalIdx = i * workingBlock + currentLocalIdx;\n"
"		nextGlobalIdx = currentGlobalIdx + 1;\n"
"		if (currentGlobalIdx <= maxGlobalIdx)\n"
"		{\n"
"			localBuf[currentLocalIdx] = sortedPairs[currentGlobalIdx];\n"
"			if (currentLocalIdx == workingBlock - 1 && nextGlobalIdx <=maxGlobalIdx) //Last thread writes additional\n"
"				localBuf[nextLocalIdx] = sortedPairs[nextGlobalIdx];\n"
"		}\n"
"		//Synchronize the local memory\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		if (currentGlobalIdx <= maxGlobalIdx && currentLocalIdx < batchSize)\n"
"		{\n"
"			uint right = localBuf[nextLocalIdx].x;\n"
"			uint thisOne = localBuf[currentLocalIdx].x;\n"
"			if (right > thisOne)\n"
"			{ \n"
"				cellRanges[thisOne].y = nextGlobalIdx;\n"
"				cellRanges[right].x = nextGlobalIdx;\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	//Post-processing for last index - Closing last pair\n"
"	if (currentGlobalIdx == maxGlobalIdx)\n"
"	{\n"
"		cellRanges[sortedPairs[currentGlobalIdx].x].y = currentGlobalIdx;\n"
"	}\n"
"}\n"
"\n"
"/*****************************************************\n"
" * 4. Counts leaf cells\n"
" ******************************************************/\n"
"__kernel void countLeavesAndFillCellKernel(CL_GLOBAL CL_UINT2* range, CL_GLOBAL CL_UINT* counters,\n"
" CL_GLOBAL struct TopLevelCell* cells, CL_UINT cellsCount,CL_CONSTANT struct GridData* grid)\n"
"{\n"
"	if (get_global_id(0) < cellsCount)\n"
"		fillTopLevelCell(range,counters,cells,grid,get_global_id(0));\n"
"}\n"
"\n"
"\n"
"/*****************************************************\n"
" * 5. Update top leaf cell with beginning of its range\n"
" ******************************************************/\n"
"__kernel void updateTopLevelCellsWithLeafRange(CL_GLOBAL struct TopLevelCell* topLevelCells,\n"
"											   CL_GLOBAL CL_UINT* leafCountsPerCell,\n"
"											   CL_UINT cellCount)\n"
"{\n"
"	CL_UINT idx = get_global_id(0);\n"
"	if (idx > 0)\n"
"		topLevelCells[idx].firstLeafIdx = leafCountsPerCell[idx-1];\n"
"}\n"
"\n"
"/*****************************************************\n"
" * 6. Count leaf pairs\n"
" ******************************************************/\n"
"__kernel void prepareGridDataForLeaves(CL_GLOBAL const char* scene, \n"
"									   CL_GLOBAL CL_UINT2* topLevelPairs,\n"
"									   CL_UINT topLevelPairsCount,\n"
"									   CL_CONSTANT struct GridData* grid,\n"
"									   CL_GLOBAL struct TopLevelCell* topLevelCells,\n"
"									   CL_GLOBAL CL_UINT* counters)\n"
"{\n"
"	CL_UINT idx = get_global_id(0); \n"
"	if (idx < topLevelPairsCount)\n"
"		counters[idx] = countLeafPairs(scene,topLevelPairs,idx,grid,topLevelCells);\n"
"	else\n"
"		counters[idx] = 0;\n"
"}\n"
"\n"
"\n"
"/*****************************************************\n"
" * 7. Write leaf pairs\n"
" ******************************************************/\n"
"__kernel void writeLeafPairsKernel(CL_GLOBAL const char* scene,\n"
"						   CL_GLOBAL CL_UINT2* topLevelPairs,\n"
"						   CL_GLOBAL struct TopLevelCell* topLevelCells,\n"
"					       CL_CONSTANT struct GridData* grid,\n"
"					       CL_GLOBAL CL_UINT* prefixSum,\n"
"					       CL_GLOBAL CL_UINT* counters,\n"
"					       CL_GLOBAL CL_UINT2* pairs,\n"
"						   CL_UINT pairCount)\n"
"{\n"
"	uint idx = get_global_id(0);\n"
"	if(idx < pairCount)\n"
"		writeLeafPairs(scene,topLevelPairs,topLevelCells,idx,grid,prefixSum,counters,pairs);\n"
"}\n"
"\n"
"/*****************************************************\n"
" * 8. Extract ranges for leaf cells\n"
" ******************************************************/\n"
"__kernel void extractLeafCellsKernel(CL_GLOBAL CL_UINT2* sortedLeafPairs,\n"
"						   CL_UINT sortedLeafPairsCount,\n"
"						   CL_GLOBAL CL_UINT2* leafCellRanges,\n"
"						   CL_LOCAL CL_UINT2* localBuf)\n"
"{\n"
"	const uint batchSize = get_local_size(0);\n"
"	const uint batches = ceil((float)get_global_size(0) / (float)batchSize);\n"
"	\n"
"	uint maxGlobalIdx = sortedLeafPairsCount - 1;\n"
"	uint currentLocalIdx = get_global_id(0);\n"
"	uint nextLocalIdx;\n"
"	long currentGlobalIdx;\n"
"	uint nextGlobalIdx;\n"
"	for(int i = 0; i < batches; i++)\n"
"	{\n"
"		//load pairs to shared memory\n"
"		nextLocalIdx = currentLocalIdx + 1;\n"
"		currentGlobalIdx = i * batchSize + currentLocalIdx;\n"
"		nextGlobalIdx = currentGlobalIdx + 1;\n"
"		if (currentGlobalIdx <= maxGlobalIdx)\n"
"		{\n"
"			localBuf[currentLocalIdx] = sortedLeafPairs[currentGlobalIdx];\n"
"			if (currentLocalIdx == batchSize - 1 && nextGlobalIdx <=maxGlobalIdx) //Last thread writes additional\n"
"				localBuf[nextLocalIdx] = sortedLeafPairs[nextGlobalIdx];\n"
"		}\n"
"		//Synchronize the local memory\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		if (currentGlobalIdx <= maxGlobalIdx && currentLocalIdx < batchSize)\n"
"		{\n"
"			uint right = localBuf[nextLocalIdx].x;\n"
"			uint thisOne = localBuf[currentLocalIdx].x;\n"
"			if (right > thisOne)\n"
"			{ \n"
"				leafCellRanges[thisOne].y = nextGlobalIdx;\n"
"				leafCellRanges[right].x = nextGlobalIdx;\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	//Post-processing for last index - Closing last pair\n"
"	if (currentGlobalIdx == maxGlobalIdx)\n"
"		leafCellRanges[sortedLeafPairs[currentGlobalIdx].x].y = currentGlobalIdx;\n"
"}\n"
"\n"
"\n"
"/*****************************************************\n"
" * 9. Generate contacts for viewing rays\n"
" ******************************************************/\n"
"__kernel __attribute__((work_group_size_hint(1, 1, 64)))\n"
" void generateContactsKernel(CL_CONSTANT struct Camera* camera,\n"
"									 CL_GLOBAL char* scene,\n"
"									 CL_CONSTANT struct GridData* gridData,\n"
"									 CL_GLOBAL struct TopLevelCell* topLevelCells,\n"
"									 CL_GLOBAL CL_UINT2* leavesArray,\n"
"									 CL_GLOBAL CL_UINT2* pairsRefArray,\n"
"									 CL_GLOBAL struct Contact* output)\n"
"{\n"
"	const CL_UINT maxRays = camera->resX * camera->resY;\n"
"	const CL_UINT myIdx = get_global_id(0);\n"
"	if (myIdx < maxRays)\n"
"	{\n"
"			const struct Ray ray = generateRay(camera,myIdx);\n"
"			struct Contact result = tlg_generate_contact(ray,scene,gridData,topLevelCells,leavesArray,pairsRefArray);\n"
"			result.pixelIndex = myIdx;\n"
"			output[myIdx] = result;\n"
"	} \n"
"}\n"
"\n"
"/*****************************************************\n"
" * 9. Generate contacts for general rays\n"
" ******************************************************/\n"
"__kernel __attribute__((work_group_size_hint(1, 1, 64)))\n"
" void generateContacts2Kernel(CL_GLOBAL struct Ray* rays,\n"
"									 uint rayCount,\n"
"									 CL_GLOBAL char* scene,\n"
"									 CL_CONSTANT struct GridData* gridData,\n"
"									 CL_GLOBAL struct TopLevelCell* topLevelCells,\n"
"									 CL_GLOBAL CL_UINT2* leavesArray,\n"
"									 CL_GLOBAL CL_UINT2* pairsRefArray,\n"
"									 CL_GLOBAL struct Contact* output)\n"
"{\n"
"	const CL_UINT myIdx = get_global_id(0);\n"
"	if (myIdx < rayCount)\n"
"	{\n"
"		struct Contact result = tlg_generate_contact(rays[myIdx],scene,gridData,topLevelCells,leavesArray,pairsRefArray);\n"
"		result.pixelIndex = myIdx;\n"
"		output[myIdx] = result;\n"
"	} \n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
;
